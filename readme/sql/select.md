# - 데이터 질의어 (SELECT문)

개발/SQL

#### DQL ( Data Query Language ) - 데이터 질의어 (SELECT문)

_민자이 ( ja-e )_ 2022. 3. 13. 00:00

#### **DQL ( Data Query Language )**

> \- DML 명령어들 중에서 SELECT문만을 따로 분류하여, DQL( Data Query Language )이라고도 함.\
> \- 따로 분류하여 정의할만큼, 가장 중요하고 많이 사용되는 구문

#### **SELECT문의 형식**

> ```
> /* 필수 구문 */
> SELECT [컬럼명1], [컬럼명2], [...] --> 실행 우선순위 5
> FROM [테이블명] --> 실행 우선순위 1
>
> /* 보조 구문 */
> WHERE [조건절] --> 실행 우선순위 2
> GROUP BY [컬럼명] --> 실행 우선순위 3
> HAVING [조건절] --> 실행 우선순위 4
> ORDER BY [컬럼명] ASC/DESC --> 실행 우선순위 6
> LIMIT [시작점, 길이] --> 실행 우선순위 7
> ```
>
> \- SELECT문은 기본적으로 위와 같은 형태를 가지며, 각 절마다 먼저 실행되는 우선 순위가 있으

#### **SELECT, FROM**

> ```
> 1. SELECT * FROM 테이블명; --> 테이블 전체 조회
> 2. SELECT [컬럼명1], [컬럼명2], ... FROM 테이블명; --> 테이블의 해당 컬럼만 조회
> 3. SELECT [*/컬럼명1, ...] INTO 새테이블명 FROM 테이블명; --> 데이터를 가져와 새 테이블에 삽입
> ```
>
> \- 가장 기본적인 SELECT 문의 형태\
> \- 두 개 이상의 테이블을 조회할 때에는 '테이블명.컬럼명'으로 조회\
> \- SELECT 문에 \*을 입력하면 해당 테이블의 모든 데이터를 볼 수 있고, 컬럼명을 입력하면 테이블 내부의 해당 컬럼만 데이터롤 조회 할 수 있음\
> \- SELECT 뒤에 INTO문을 입력하여, 조회된 데이터를 기반으로 새 테이블 생성 가능\
> ( 하단에 기술할 WHERE 조건절을 응용하여, 데이터 없이 컬럼 형식만 가져올 수 있음\
> → ex : SELECT \* INTO \[새테이블명] FROM \[테이블명] WHERE 1=2\
> ※ '1=2'는 false임을 이용하여 데이터는 조회하지 않고 컬럼의 형식만 가져옴)

#### **SELECT > DISTINCT**

> ```
> 1. SELECT DISTINCT 컬럼명 FROM 테이블명;
> 2. SELECT DISTINCT [컬럼명1], [컬럼명2], [...] FROM 테이블명;
> ```
>
> \- DISTINCT의 대상이 되는 컬럼에 중복 값이 있을 경우, 첫 번째 값을 제외하고 나머지는 제거\
> \- 대상 컬럼이 여러 개일 경우, 해당 컬럼 값이 모두 동일해야 제거\
> \- SELECT의 대상 일부에만 DISTINCT를 적용 할 수 없음\
> → DISTINCT의 중복 제거 대상은 SELECT절의 모든 컬럼을 대상으로 함\
> → 일부 컬럼만 중복 제거를 하기 위해선 서브쿼리와의 조합 필요

#### **WHERE**

> ```
> SELECT [컬럼명]
> FROM [테이블명] 
> WHERE [컬럼명] [연산자];
> ```
>
> \- 조건에 해당하는 컬럼만 조회하고 싶을 때 사용

#### **'WHERE'절에 사용되는 연산자 종류**

| **비교 연산자**                | <p>'>, >=, &#x3C;, &#x3C;=, !=, &#x3C;>, =' 와 같은 연산자로 값을 비교하여 데이터를 선택<br>ex) WHERE a = 1; → a가 1인 데이터</p>                      |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **(NOT) BETWEEN a AND b** | <p>a 이상 b 이하의 값을 가지는 데이터를 선택<br>ex) WHERE a BETWEEN 10 AND 20; → a의 값이 10 이상 20 이하인 데이터</p>                                    |
| **(NOT) IN**              | <p>비연속적인 다수의 값을 선택<br>ex) WHERE a IN (10,20,30); → a의 값이 10 또는 20 또는 30인 데이터</p>                                               |
| **(NOT) LIKE**            | <p>특정 패턴의 문자열을 선택<br>※ '%' : 0개 이상의 모든 문자열을 의미 / '_' : 단일 문자 하나를 의미<br>ex) WHERE a LIKE '_A%';  → a의 값 중 두번째 글자가 A인 모든 데이터</p> |
| **IS (NOT) NULL**         | <p>값이 NULL인 데이터를 선택<br>ex) WHERE a IS NULL; → a의 값이 null인 데이터</p>                                                              |
| **(NOT) EXISTS**          | <p>IN과 유사하나, 서브쿼리만을 대상으로 사용하며 작업 방식의 차이로 성능이 더 좋음<br><a href="https://gent.tistory.com/278">ex) 링크 참고</a></p>                  |

​※ NOT을 사용하면 조건에 해당하지 않는 데이터만 조회

#### **AND, OR**

```
SELECT *
FROM employees
WHERE id = 1 OR age >= 30 AND salary > 10000;
--> AND의 우선 순위가 더 높으므로 'age >= 30'과 'salary > 10000'이 묶어짐
--> 최종적으로, 조건 묶음은 'id = 1'과 'age >= 30 AND salary > 10000'로 나눠짐
--> 후순위인 OR에 따라 조건 묶음이 분류되어, 조건 둘 중 하나만 만족해도 해당 데이터를 반환

WHERE ( id = 1 OR age >= 30 ) AND salary > 10000;
--> 괄호를 이용해 조건을 따로 묶어주어, AND보다 높은 우선순위를 줄 수 있음
--> 위 조건은 'id = 1' 또는 'age >= 30'중 하나를 만족하면서 salary도 10000을 초과하는 데이터를 반환
```

| **AND** | AND 앞에 있는 조건과 뒤에 있는 조건이 모두 참이어야 해당 데이터를 반환 ( 우선순위 1 )   |
| ------- | ------------------------------------------------------- |
| **OR**  | OR 앞에 있는 조건과 뒤에 있는 조건 중에 하나만 참이어도 해당 데이터를 반환 ( 우선순위 2 ) |

#### **GROUP BY**

> ```
> SELECT [컬럼명1], [...], [집계 함수] --> 집계 함수가 필수는 아니지만, GROUP BY의 목적상 보통 같이 쓰임
> FROM 테이블
> GROUP BY 그룹화할컬럼
>
> ex ↓
> SELECT 부서, count(부서) AS 사원수 
> --> 부서를 그룹화한 뒤, 사원별 부서를 집계하여 해당 부서의 사원수를 반환
> FROM 사원테이블
> GROUP BY 부서
> ```

| **id** | **사원명** | **부서** |
| ------ | ------- | ------ |
| 1      | 사원A     | 개발     |
| 2      | 사원B     | 개발     |
| 3      | 사원C     | 마케팅    |

> \
> **↓** 위의 테이블을 예시 코드대로 실행했을 시 나타나는 결과 - 중복되는 컬럼의 값들을 그룹화한 뒤, 집계 함수를 통해 다양한 결과를 나타낼 수 있는 명령어

#### **집계 함수의 종류**

| **COUNT(\*)**  | 'null'인 값을 포함하여 행의 수를 반환         |
| -------------- | -------------------------------- |
| **COUNT(컬럼명)** | 해당 컬럼 중 'null'인 값을 제외하고 행의 수를 반환 |
| **SUM(컬럼명)**   | 해당 컬럼에서 'null'을 제외한 총 합계의 값을 반환  |
| **AVG(컬럼명)**   | 해당 컬럼에서 'null'을 제외한 평균의 값을 반환    |
| **MAX(컬럼명)**   | 해당 컬럼의 값들 중에 가장 큰 값을 반환          |
| **MIN(컬럼명)**   | 해당 컬럼의 값들 중에 가장 작은 값을 반환         |

​※ 표준 편차를 구하는 STDDEV, 분산을 구하는 VARIAN 등의 함수도 있지만 자주 사용되지 않음

#### **HAVING**

> ```
> SELECT [컬럼명1], [...], [집계 함수]
> FROM 테이블
> GROUP BY 그룹화할 컬럼
> HAVING 집계함수에대한조건절
>
> ex ↓
> SELECT 부서, count(부서) AS 사원수 
> FROM 사원테이블
> GROUP BY 부서
> HAVING count(부서) >= 2;
> ```
>
> \- WHERE과 비슷한 용도(조건에 맞는 데이터 반환)를 가지고 있으나, 조건 대상이 집계 함수로 한정\
> \- WHERE에는 집계 함수 사용 불가 / HAVING에는 집계 함수만 사용 가능\
> \- 순서 상 GROUP BY의 하단에만 기술해야 함 ( ※ WHERE은 GROUP의 상단에만 기술 )

#### **ORDER BY**

> ```
> SELECT [*/컬럼명1, ...] 
> FROM 테이블명
> ORDER BY 컬럼명/컬럼의위치/AS(앨리아스)값 [ASC/DESC]; --> ASC : 오름차순 / DESC : 내림차순
> --> DESC를 입력하면, 앞에 기재한 컬럼 값이 제일 높은 행부터 내림차순으로 정렬
> --> ASC를 입력하거나, 정렬값을 생략하면 해당 컬럼을 기준으로 오름차순 정렬
> --> 다수의 컬럼을 입력하면, 앞의 정렬 기준 값이 동일할 때 그 다음 기준에 따라 행을 정렬
>
> ex ↓
> SELECT 사원명, 연봉
> FROM 사원테이블
> ORDER BY 연봉 DESC, 1;
> --> 먼저 SELECT된 컬럼들이, 연봉이 제일 높은 행부터 내림차순으로 정렬[연봉 DESC;]
> --> 연봉이 동일하면 첫 번째 컬럼이 제일 낮은 값부터 오름차순으로 정렬[1 (ASC);]
> ```
>
> \- 기준이 될 컬럼을 정하고, 그 컬럼의 값이 높고 낮음에 따라 행들을 정렬하는 명령어

#### **LIMIT**

> ```
> SELECT [컬럼명1], [컬럼명2], [...]
> FROM [테이블명]
> LIMIT [시작행, 조회할 행의 수];
> --> 한 개의 숫자 파라미터만 입력하면, 첫 번째 행부터 해당 파라미터만큼 행을 조회
> --> 만약, 'LIMIT 5'를 입력하면 첫 번째 행부터 5개의 행만 조회
> --> 즉, 생략 시 시작 행의 디폴트값은 0
>
> ex ↓ (if, 차트에서 21위~30위의 노래를 조회하고자 할 때)
> SELECT 노래제목, 순위
> FROM 노래차트
> ORDER BY 순위 ASC
> LIMIT 20, 10; 
> --> 인덱스 값이 0부터 시작하므로 20이 21번째 행을 의미
> --> 21번째 행부터 시작하여, 10개의 행을 조회
> ```
>
> \- 데이터 조회 시, 일정 범위의 행만 조회하고 싶을 때 사용
